<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20211015160132.1"><vh>@clean squeaklib/__init__.py</vh>
<v t="karstenw.20211015160216.1"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20211015160313.1"><vh>@clean squeaklib/point.py</vh>
<v t="karstenw.20211015171659.1"><vh>declarations</vh></v>
<v t="karstenw.20211015172141.1"><vh>tools</vh>
<v t="karstenw.20210401150717.1"><vh>sign</vh></v>
</v>
<v t="karstenw.20211015171541.1"><vh>Point</vh>
<v t="karstenw.20211015171541.2"><vh>__python__</vh>
<v t="karstenw.20211015171541.3"><vh>__init__</vh></v>
<v t="karstenw.20211015171541.4"><vh>__repr__</vh></v>
<v t="karstenw.20211015171541.5"><vh>__lt|le|gt|ge|eq|ne|add|sub|mul__</vh></v>
</v>
<v t="karstenw.20211015171541.6"><vh>instance methods</vh>
<v t="karstenw.20211015171541.7"><vh>converting</vh>
<v t="karstenw.20211015171541.8"><vh>asFloatPoint</vh></v>
<v t="karstenw.20211015171541.9"><vh>asIntegerPoint</vh></v>
<v t="karstenw.20211015171541.10"><vh>corner -&gt; Rectangle</vh></v>
<v t="karstenw.20211015171541.11"><vh>extent -&gt; Rectangle</vh></v>
<v t="karstenw.20211015171541.12"><vh>isPoint</vh></v>
<v t="karstenw.20211015171541.13"><vh>rect -&gt; Rectangle</vh></v>
<v t="karstenw.20211015171541.14"><vh>asArray</vh></v>
</v>
<v t="karstenw.20211015171541.15"><vh>copying</vh></v>
<v t="karstenw.20211015171541.16"><vh>geometry</vh></v>
<v t="karstenw.20211015171541.17"><vh>point functions</vh>
<v t="karstenw.20211015171541.18"><vh>interpolateToAt</vh></v>
<v t="karstenw.20211015171541.19"><vh>bearingToPoint</vh></v>
<v t="karstenw.20211015171541.20"><vh>crossProduct</vh></v>
<v t="karstenw.20211015171541.21"><vh>dist</vh></v>
<v t="karstenw.20211015171541.22"><vh>dotProduct</vh></v>
<v t="karstenw.20211015171541.23"><vh>eightNeighbors</vh></v>
<v t="karstenw.20211015171541.24"><vh>fourNeighbors</vh></v>
<v t="karstenw.20211015171541.25"><vh>flipByCenterAt</vh></v>
<v t="karstenw.20211015171541.26"><vh>grid</vh></v>
<v t="karstenw.20211015171541.27"><vh>insideTriangle</vh></v>
<v t="karstenw.20211015171541.28"><vh>nearestPointAlongLineFromTo</vh></v>
<v t="karstenw.20211015171541.29"><vh>skalarPointOnLine</vh></v>
<v t="karstenw.20211015171541.30"><vh>normal</vh></v>
<v t="karstenw.20211015171541.31"><vh>normalized</vh></v>
<v t="karstenw.20211015171541.32"><vh>octantOf</vh></v>
<v t="karstenw.20211015171541.33"><vh>onLineFromTo</vh></v>
<v t="karstenw.20211015171541.34"><vh>onLineFromToWithin</vh></v>
<v t="karstenw.20211015171541.35"><vh>quadrantOf</vh></v>
<v t="karstenw.20211015171541.36"><vh>rotateByCenterAt</vh></v>
<v t="karstenw.20211015171541.37"><vh>sortsBefore</vh></v>
<v t="karstenw.20211015171541.38"><vh>squaredDistanceTo</vh></v>
<v t="karstenw.20211015171541.39"><vh>transposed</vh></v>
</v>
<v t="karstenw.20211015171541.40"><vh>polar coordinates</vh>
<v t="karstenw.20211015171541.41"><vh>degrees</vh></v>
<v t="karstenw.20211015171541.42"><vh>degreesWith</vh></v>
<v t="karstenw.20211015171541.43"><vh>r</vh></v>
<v t="karstenw.20211015171541.44"><vh>theta</vh></v>
</v>
<v t="karstenw.20211015171541.45"><vh>private</vh>
<v t="karstenw.20211015171541.46"><vh>bitShiftPoint</vh></v>
<v t="karstenw.20211015171541.47"><vh>setRDegrees</vh></v>
</v>
<v t="karstenw.20211015171541.48"><vh>transforming</vh>
<v t="karstenw.20211015171541.49"><vh>adhereTo</vh></v>
<v t="karstenw.20211015171541.50"><vh>negated</vh></v>
<v t="karstenw.20211015171541.51"><vh>scaleBy</vh></v>
<v t="karstenw.20211015171541.52"><vh>scaleFromTo</vh></v>
<v t="karstenw.20211015171541.53"><vh>rotateByAboutCenter</vh></v>
<v t="karstenw.20211015171541.54"><vh>translateBy</vh></v>
</v>
<v t="karstenw.20211015171541.55"><vh>truncation and round off</vh>
<v t="karstenw.20211015171541.56"><vh>rounded</vh></v>
<v t="karstenw.20211015171541.57"><vh>truncateTo</vh></v>
<v t="karstenw.20211015171541.58"><vh>truncated</vh></v>
</v>
</v>
<v t="karstenw.20211015171541.59"><vh>testing</vh>
<v t="karstenw.20211015171541.60"><vh>isZero</vh></v>
</v>
<v t="karstenw.20211015171541.61"><vh>class methods</vh>
<v t="karstenw.20211015171541.62"><vh>instance creation</vh>
<v t="karstenw.20211015171541.63"><vh>rhoDegrees</vh></v>
</v>
</v>
</v>
</v>
<v t="karstenw.20211015160327.1" a="E"><vh>@clean squeaklib/rectangle.py</vh>
<v t="karstenw.20211015171830.1"><vh>declarations</vh></v>
<v t="karstenw.20211015171522.1" a="E"><vh>Rectangle</vh>
<v t="karstenw.20211015171522.2"><vh>__python__</vh>
<v t="karstenw.20211015171522.3"><vh>__init__</vh></v>
<v t="karstenw.20211015171522.4"><vh>__repr__</vh></v>
<v t="karstenw.20211015171522.5"><vh>__eq|ne|add|sub|mul__</vh></v>
</v>
<v t="karstenw.20211015171522.6" a="E"><vh>properties</vh>
<v t="karstenw.20211015171522.7"><vh>origin corner</vh></v>
<v t="karstenw.20211015171522.8"><vh>height width area</vh></v>
<v t="karstenw.20211015171522.9"><vh>top left bottom right</vh></v>
<v t="karstenw.20211015171522.10"><vh>topleft topright bottomleft bottomright</vh></v>
<v t="karstenw.20211015171522.11"><vh>center</vh></v>
<v t="karstenw.20211015171522.12"><vh>bottomcenter topcenter leftcenter rightcenter</vh></v>
<v t="karstenw.20211015171522.13"><vh>corners extent</vh></v>
<v t="karstenw.20230525123613.1"><vh>lines</vh></v>
</v>
<v t="karstenw.20211015171522.14" a="E"><vh>instance methods</vh>
<v t="karstenw.20211015171522.15"><vh>rectangle methods</vh>
<v t="karstenw.20211015171522.16"><vh>withRight</vh></v>
<v t="karstenw.20211015171522.17"><vh>withLeft</vh></v>
<v t="karstenw.20211015171522.18"><vh>withBottom</vh></v>
<v t="karstenw.20211015171522.19"><vh>withTop</vh></v>
<v t="karstenw.20211015171522.20"><vh>withSideSetTo</vh></v>
<v t="karstenw.20211015171522.21"><vh>withHeight</vh></v>
<v t="karstenw.20211015171522.22"><vh>withWidth</vh></v>
<v t="karstenw.20211015171522.23"><vh>amountToTranslateWithin</vh></v>
<v t="karstenw.20211015171522.24"><vh>areasOutside</vh></v>
<v t="karstenw.20211015171522.25"><vh>asArray</vh></v>
<v t="karstenw.20211015171522.26"><vh>asPointList</vh></v>
<v t="karstenw.20211015171522.27"><vh>bordersOnAlong</vh></v>
<v t="karstenw.20211015171522.28"><vh>encompass</vh></v>
<v t="karstenw.20211015171522.29"><vh>expandBy</vh></v>
<v t="karstenw.20211015171522.30"><vh>extendBy</vh></v>
<v t="karstenw.20211015171522.31"><vh>insetBy</vh></v>
<v t="karstenw.20211015171522.32"><vh>insetOriginAndCornerBy</vh></v>
<v t="karstenw.20211015171522.33"><vh>intersect</vh></v>
<v t="karstenw.20211015171522.34"><vh>merge</vh></v>
<v t="karstenw.20211015171522.35"><vh>outsetBy</vh></v>
<v t="karstenw.20211015171522.36"><vh>pointNearestTo</vh></v>
<v t="karstenw.20211015171522.37"><vh>quickMerge</vh></v>
<v t="karstenw.20211015171522.38"><vh>rectanglesAtHeight</vh></v>
<v t="karstenw.20211015171522.39"><vh>sideNearestTo</vh></v>
<v t="karstenw.20211015171522.40"><vh>translatedToBeWithin</vh></v>
<v t="karstenw.20211015171522.41"><vh>withSideOrCornerSetToPoint</vh></v>
<v t="karstenw.20211015171522.42"><vh>withSideOrCornerSetToPointMinExtent</vh></v>
<v t="karstenw.20211015171522.43"><vh>withSideOrCornerSetToPointMinExtentLimit</vh></v>
</v>
<v t="karstenw.20211015171522.44"><vh>testing</vh>
<v t="karstenw.20211015171522.45"><vh>containsPoint</vh></v>
<v t="karstenw.20211015171522.46"><vh>containsRect</vh></v>
<v t="karstenw.20211015171522.47"><vh>fullIntersects</vh></v>
<v t="karstenw.20211015171522.48"><vh>hasPositiveExtent</vh></v>
<v t="karstenw.20211015171522.49"><vh>intersects</vh></v>
<v t="karstenw.20211015171522.50"><vh>isTall</vh></v>
<v t="karstenw.20211015171522.51"><vh>isWide</vh></v>
<v t="karstenw.20211015171522.52"><vh>isZero</vh></v>
</v>
<v t="karstenw.20211015171522.53"><vh>truncation and round off</vh>
<v t="karstenw.20211015171522.54"><vh>rounded</vh></v>
<v t="karstenw.20211015171522.55"><vh>truncateTo</vh></v>
<v t="karstenw.20211015171522.56"><vh>truncated</vh></v>
</v>
<v t="karstenw.20211015171522.57" a="E"><vh>transforming</vh>
<v t="karstenw.20211015171522.58"><vh>alignWith</vh></v>
<v t="karstenw.20211015171522.59"><vh>centeredBeneath</vh></v>
<v t="karstenw.20211015171522.60"><vh>flipByCenterAt</vh></v>
<v t="karstenw.20211015171522.61"><vh>rotateByCenterAt</vh></v>
<v t="karstenw.20211015171522.62"><vh>scaleBy</vh></v>
<v t="karstenw.20211015171522.63"><vh>scaleFromTo</vh></v>
<v t="karstenw.20211015171522.64"><vh>squishedWithin</vh></v>
<v t="karstenw.20211015171522.65"><vh>translateBy</vh></v>
<v t="karstenw.20211015171522.66"><vh>translatedAndSquishedToBeWithin</vh></v>
</v>
<v t="karstenw.20230522211615.1" a="E"><vh>subdivision</vh>
<v t="karstenw.20230522211654.1"><vh>split</vh></v>
</v>
<v t="karstenw.20211015171522.67" a="E"><vh>inRect</vh>
<v t="karstenw.20230525122537.1"><vh>innerSquare</vh></v>
<v t="karstenw.20230525122546.1"><vh>outerSquare</vh></v>
</v>
</v>
<v t="karstenw.20211015171522.68"><vh>class methods</vh>
<v t="karstenw.20211015171522.69"><vh>instance creation</vh>
<v t="karstenw.20211015171522.70"><vh>centerExtent</vh></v>
<v t="karstenw.20211015171522.71"><vh>encompassing</vh></v>
<v t="karstenw.20211015171522.72"><vh>leftRightTopBottom</vh></v>
<v t="karstenw.20211015171522.73"><vh>merging</vh></v>
<v t="karstenw.20211015171522.74"><vh>originExtent</vh></v>
</v>
</v>
</v>
<v t="karstenw.20230525121754.1"><vh>Region</vh></v>
</v>
<v t="karstenw.20211015172441.1"><vh>@clean squeaklib/form.py</vh>
<v t="karstenw.20211015172515.1"><vh>Declarations</vh></v>
<v t="karstenw.20211015172526.1"><vh>class Form</vh>
<v t="karstenw.20211015172526.2"><vh>__init__</vh></v>
<v t="karstenw.20211015172526.3"><vh>__repr__</vh></v>
<v t="karstenw.20211015172526.4"><vh>BITS</vh>
<v t="karstenw.20211015172526.5"><vh>getbits</vh></v>
<v t="karstenw.20211015172526.6"><vh>setbits</vh></v>
</v>
<v t="karstenw.20211015172526.7"><vh>WIDTH &amp; HEIGHT</vh>
<v t="karstenw.20211015172526.8"><vh>getwidth</vh></v>
<v t="karstenw.20211015172526.9"><vh>setwidth</vh></v>
<v t="karstenw.20211015172526.10"><vh>getheight</vh></v>
<v t="karstenw.20211015172526.11"><vh>setheight</vh></v>
</v>
<v t="karstenw.20211015172526.12"><vh>center</vh></v>
<v t="karstenw.20211015172526.13"><vh>classmethods</vh>
<v t="karstenw.20211015172526.14"><vh>extent</vh></v>
<v t="karstenw.20211015172526.15"><vh>extentMode</vh></v>
<v t="karstenw.20211015172526.16"><vh>dotOfSize</vh></v>
</v>
</v>
<v t="karstenw.20211015172603.1"><vh>imageRectangles</vh></v>
</v>
<v t="karstenw.20211017122643.1"><vh>trash</vh>
<v t="karstenw.20211015201020.1"><vh>subdivision</vh>
<v t="karstenw.20211015201030.1"><vh>split</vh></v>
<v t="karstenw.20211017114859.1"><vh>quadsplit</vh></v>
<v t="karstenw.20211017115305.1"><vh>outerrects</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20210401150717.1">def sign( number ):
    """I can't believe that Python does not have a sign() function."""

    if number &gt; 0:
        return +1
    elif number &lt; 0:
        return -1
    return 0


</t>
<t tx="karstenw.20211015160132.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20211015160216.1">
from . import point, rectangle, form, makepoint

Point = point.Point
Rectangle = rectangle.Rectangle
Form = form.Form

makePoint = makepoint.makePoint
imageRectangles = form.imageRectangles

point.Rectangle = Rectangle
point.makePoint = makePoint
rectangle.Point = Point
rectangle.makePoint = makePoint
form.Point = Point
form.Rectangle = Rectangle
form.makePoint = makePoint
makepoint.Point = Point

</t>
<t tx="karstenw.20211015160313.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20211015160327.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20211015171522.1">class Rectangle(object):
    "Translated from a Squeak 3.7 image"

    @others
</t>
<t tx="karstenw.20211015171522.10"># topleft
def gettopleft( self ):
    return self.origin
def settopleft( self, *args):
    self.origin = makePoint( args )
topleft = property( gettopleft, settopleft )

# topright
def gettopright( self ):
    return Point( self.corner.x, self.origin.y )
def settopright( self, *args):
    p = makePoint( args )
    self.corner.x = p.x
    self.origin.y = p.y
topright = property( gettopright, settopright )

# bottomleft
def getbottomleft( self ):
    return Point( self.origin.x, self.corner.y )
def setbottomleft( self, *args):
    p = makePoint( args )
    self.origin.x = p.x
    self.corner.y = p.y
bottomleft = property( getbottomleft, setbottomleft )

# bottomright
def getbottomright( self ):
    return self.corner
def setbottomright( self, *args):
    self.corner = makePoint( args )
bottomright = property( getbottomright, setbottomright )

</t>
<t tx="karstenw.20211015171522.11"># center
def getcenter( self ):
    return Point( self.left + self.width / 2.0,
                        self.top + self.height / 2.0 )
def setcenter( self, *args):
    center = makePoint( args )
    ext = self.extent
    half = ext / 2.0
    self.origin = center - half
    self.corner = center + half
center = property( getcenter, setcenter )

</t>
<t tx="karstenw.20211015171522.12"># bottomcenter
def bottomcenter( self ):
    return Point( self.center.x, self.bottom )
bottomcenter = property( bottomcenter )

# topcenter
def topcenter( self ):
    return Point( self.center.x, self.top )
topcenter = property( topcenter )

# leftcenter
def leftcenter( self ):
    return Point( self.left, self.center.y )
leftcenter = property( leftcenter )

# rightcenter
def rightcenter( self ):
    return Point( self.right, self.center.y )
rightcenter = property( rightcenter )

</t>
<t tx="karstenw.20211015171522.13">def getcorners( self ):
    return [
        self.topleft,
        self.bottomleft,
        self.bottomright,
        self.topright
    ]
def setcorners( self, topLeft, bottomleft, bottomright, topright ):
    self.origin( topLeft )
    self.corner( bottomRight )
corners = property( getcorners )

def getextent( self ):
    return self.corner - self.origin
def setextent( self, aPoint ):
    self.corner( self.origin + aPoint )
extent = property( getextent, setextent )


</t>
<t tx="karstenw.20211015171522.14"></t>
<t tx="karstenw.20211015171522.15"></t>
<t tx="karstenw.20211015171522.16">def withRight( self, x ):
    """Return a copy of me with a different right x"""
    return Rectangle( self.origin, Point( x, self.corner.y))

</t>
<t tx="karstenw.20211015171522.17">def withLeft( self, x ):
    """Return a copy of me with a different left x"""
    return Rectangle( Point(x, self.origin.y), self.corner)

</t>
<t tx="karstenw.20211015171522.18">def withBottom( self, y ):
    """Return a copy of me with a different bottom y"""
    return Rectangle( self.origin, Point( self.corner.x, y) )

</t>
<t tx="karstenw.20211015171522.19">def withTop( self, y ):
    """Return a copy of me with a different top y"""
    return Rectangle( Point(self.origin.x, y), self.corner )

</t>
<t tx="karstenw.20211015171522.2"></t>
<t tx="karstenw.20211015171522.20">def withSideSetTo( self, side, val ):
    """return a copy with side set to value"""
    if side == "left":
        return Rectangle( Point(val, self.origin.y), self.corner )
    elif side == "right":
        return Rectangle( self.origin, Point(val, self.corner.y) )
    elif side == "top":
        return Rectangle( Point(self.origin.x, val), self.corner )
    elif side == "bottom":
        return Rectangle( self.origin, Point(self.corner.x, val) )

</t>
<t tx="karstenw.20211015171522.21">def withHeight( self, height ):
    """Return a copy of me with a different height"""
    return Rectangle( self.origin,
                      Point( self.corner.x, self.origin.y + height ))

</t>
<t tx="karstenw.20211015171522.22">def withWidth( self, width ):
    """Return a copy of me with a different width"""
    return Rectangle( self.origin,
                      Point( self.origin.x + width, self.corner.y))

</t>
<t tx="karstenw.20211015171522.23">def amountToTranslateWithin( self, aRectangle ):
    """Answer a Point, delta, such that self + delta is forced
       within aRectangle.

       Altered so as to prefer to keep self topLeft inside when all of self
       cannot be made to fit 7/27/96 di"""
    dx = dy = 0
    if self.right &gt; aRectangle.right:
        dx = aRectangle.right - self.right

    if self.bottom &gt; aRectangle.bottom:
        dy = aRectangle.bottom - self.bottom

    if (self.left + dx) &lt; aRectangle.left:
        dx = aRectangle.left - self.left

    if (self.top + dy) &lt; aRectangle.top:
        dy = aRectangle.top - self.top
    return Point(dx,dy)

</t>
<t tx="karstenw.20211015171522.24">def areasOutside( self, aRectangle ):
    """Answer an Array of Rectangles comprising the parts of the receiver
       not intersecting aRectangle."""

    areas = []
    
    # this is the negated overlap condition -&gt; no overlap -&gt; self
    if not (    (self.origin &lt;= aRectangle.corner)
            and (aRectangle.origin &lt;= self.corner)):
        #print("self")
        return [self]

    # overlap
    if aRectangle.origin.y &gt; self.origin.y:
        yOrigin = aRectangle.origin.y
        #print("other origin y is higher; append")
        areas.append( Rectangle( self.origin,
                                 Point(self.corner.x, yOrigin)) )
    else:
        #print("self origin y is higher")
        yOrigin = self.origin.y

    if aRectangle.corner.y &lt; self.corner.y:
        yCorner = aRectangle.corner.y
        #print("self corner y higher; append")
        areas.append( Rectangle( Point(self.origin.x, yCorner ),
                                 self.corner) )
    else:
        #print("self corner y lower")
        yCorner = self.corner.y

    if aRectangle.origin.x &gt; self.origin.x:
        #print("other origin x more right; append")
        areas.append( Rectangle( Point(self.origin.x, yOrigin),
                                 Point(aRectangle.origin.x, yCorner)) )

    if aRectangle.corner.x &lt; self.corner.x:
        #print("self corner more right; append")
        areas.append( Rectangle( Point(aRectangle.corner.x, yOrigin),
                                 Point(self.corner.x, yCorner) ))
    return areas

</t>
<t tx="karstenw.20211015171522.25">def asArray( self ):
    return [self.origin.x,
            self.origin.y,
            self.corner.x,
            self.corner.y]

</t>
<t tx="karstenw.20211015171522.26">def asPointList( self ):
    return [self.origin, self.corner]


</t>
<t tx="karstenw.20211015171522.27">def bordersOnAlong( self, her, herSide ):
    if (   (herSide == b"right" and self.left == her.right)
        or (herSide == b"left"  and self.right == her.left)):
        return max(self.top, her.top) &lt; min(self.bottom, her.bottom)

    if (   (herSide == b"bottom" and self.top == her.bottom)
        or (herSide == b"top"  and self.bottom == her.top)):
        return  max(self.left, her.left) &lt; min(self.right, her.right)
    return False

</t>
<t tx="karstenw.20211015171522.28">def encompass( self, aPointOrRect ):
    """Answer a Rectangle that contains both the receiver and aPoint.
       5/30/96 sw"""
    if type( aPointOrRect ) in (Rectangle,):
        return Rectangle( min(self.origin, aPointOrRect.origin),
                          max(self.corner, aPointOrRect.corner) )
    else:
        aPointOrRect = makepoint( aPointOrRect )
        return Rectangle( min(self.origin, aPointOrRect),
                          max(self.corner, aPointOrRect) )

</t>
<t tx="karstenw.20211015171522.29">def expandBy( self, delta ):
    """Answer a Rectangle that is outset from the receiver by delta.
       delta is a Rectangle, Point, or scalar."""
    if isinstance(delta, Rectangle):
        return Rectangle( self.origin - delta.origin,
                          self.corner + delta.corner)
    else:
        return Rectangle( self.origin - delta,
                          self.corner + delta)



</t>
<t tx="karstenw.20211015171522.3">def __init__(self, origin, corner):
    p1 = makePoint( origin )
    p2 = makePoint( corner )
    if p2 &lt; p1:
        p1, p2 = p2, p1
    self.porigin = p1
    self.pcorner = p2


</t>
<t tx="karstenw.20211015171522.30">def extendBy( self, delta ):
    """Answer a Rectangle with the same origin as the receiver,
       but whose corner is offset by delta. delta is a
       Rectangle, Point, or scalar."""

    if isinstance(delta, Rectangle):
        return Rectangle( self.origin, self.corner + delta.corner )
    return Rectangle( self.origin, self.corner + delta)

</t>
<t tx="karstenw.20211015171522.31">def insetBy( self, delta ):
    """Answer a Rectangle that is inset from the receiver by delta.
       delta is a Rectangle, Point, or scalar."""
    if isinstance(delta, Rectangle):
        return Rectangle( self.origin + delta.origin,
                          self.corner - delta.corner )
    return Rectangle( self.origin + delta,
                      self.corner - delta)


</t>
<t tx="karstenw.20211015171522.32">def insetOriginAndCornerBy( self, originDeltaPoint, cornerDeltaPoint ):
    """Answer a Rectangle that is inset from the receiver by a given
       amount in the origin and corner."""
    return Rectangle( self.origin + originDeltaPoint,
                      self.corner - cornerDeltaPoint )


</t>
<t tx="karstenw.20211015171522.33">def intersect( self, aRectangle ):
    """Answer a Rectangle that is the area in which the receiver overlaps
       with aRectangle. Optimized for speed; old code read:
        ^Rectangle 
            origin: (origin max: aRectangle origin)
            corner: (corner min: aRectangle corner)"""
    if 0: # old code
        return Rectangle( max(self.origin, aRectangle.origin),
                          min(sel.corner, aRectangle.corner) )
    else:
        left = right = top = bottom = 0
        aPoint = aRectangle.origin
        if aPoint.x &gt; origin.x:
            left = aPoint.x
        else:
            left = origin.x

        if aPoint.y &gt; origin.y:
            top = aPoint.y
        else:
            top = origin.y

        aPoint = aRectangle.corner
        if aPoint.x &lt; self.corner.x:
            right = aPoint.x
        else:
            right = self.corner.x
        
        if aPoint.y &lt; corner.y:
            bottom = aPoint.y
        else:
            bottom = corner.y
        return Rectangle( (left,top), (right, bottom) )


</t>
<t tx="karstenw.20211015171522.34">def merge( self, aRectangle ):
    """Answer a Rectangle that contains both the receiver
       and aRectangle."""
    return Rectangle( min(self.origin, aRectangle.origin),
                      max(self.corner, aRectangle.corner) )

</t>
<t tx="karstenw.20211015171522.35">def outsetBy( self, delta ):
    """Answer a Rectangle that is outset from the receiver by delta.
       delta is a Rectangle, Point, or scalar."""
    if isinstance( delta, Rectangle ):
        return Rectangle(self.origin - delta.origin,
                         self.corner + delta.corner)
    else:
        return Rectangle(self.origin - delta,
                         self.corner + delta)


</t>
<t tx="karstenw.20211015171522.36">def pointNearestTo( self, aPoint ):
    """Return the point on my border closest to aPoint"""
    side = ""
    if self.containsPoint( aPoint ):
        side = self.sideNearestTo( aPoint )
        if side == "right":
            return Point( self.right, aPoint.y )
        elif side == "left":
            return Point( self.left, aPoint.y )
        elif side == "bottom":
            return Point( aPoint.x, self.bottom )
        elif side == "top":
            return Point( aPoint.x, self.top )
    else:
        return aPoint.adhereTo( self )


</t>
<t tx="karstenw.20211015171522.37">def quickMerge( self, aRectangle ):
    """Answer the receiver if it encloses the given rectangle or the
       merge of the two rectangles if it doesn't. THis method is an
       optimization to reduce extra rectangle creations."""
    
    useReceiver = True
    rOrigin = aRectangle.topLeft
    rCorner = aRectangle.bottomRight

    if rOrigin.x &lt; self.origin.x:
        useReceiver = False
        minX = rOrigin.x
    else:
        minX = self.origin.x
    
    if rCorner.x &gt; self.corner.x:
        useReceiver = False
        maxX = rCorner.x
    else:
        maxX = self.corner.x
    
    if rOrigin.y &lt; self.origin.y:
        useReceiver = False
        minY = r.Origin.y
    else:
        minY = self.Origin.y
    
    if rCorner.y &gt; self.corner.y:
        useReceiver = False
        maxY = rCorner.y
    else:
        maxY = self.corner.y
    
    if useReceiver:
        return self
    else:
        return Rectangle( Point(minX, minY), Point(maxX, maxY) )

</t>
<t tx="karstenw.20211015171522.38">def rectanglesAtHeight( self, y, ht ):
    if (y + ht) &gt; self.bottom:
        return []
    return [ Rectangle( Point(self.origin.x, y),
                        Point(self.corner.x, (y+ht)) ) ]

</t>
<t tx="karstenw.20211015171522.39">def sideNearestTo( self, aPoint ):
    aPoint = makePoint( aPoint )
    distToLeft = aPoint.x - self.left
    distToRight = self.right - aPoint.x
    distToTop = aPoint.y - self.top
    distToBottom = self.bottom - aPoint.y
    closest = distToLeft
    side = "left"
    if distToRight &lt; closest:
        closest = distToRight
        side = "right"
    if distToTop &lt; closest:
        closest = distToTop
        side = "top"
    if distToBottom &lt; closest:
        closest = distToBottom
        side = "bottom"
    return side
        
</t>
<t tx="karstenw.20211015171522.4">def __repr__( self ):
    return u"Rectangle( %s, %s )" % (repr(self.origin), repr(self.corner) )


</t>
<t tx="karstenw.20211015171522.40">def translatedToBeWithin( self, aRectangle ):
    """Answer a copy of the receiver that does not extend
       beyond aRectangle.  7/8/96 sw"""
    return self.translatedBy( self.amountToTranslateWithin( aRectangle ))


</t>
<t tx="karstenw.20211015171522.41">def withSideOrCornerSetToPoint( self, side, newPoint ):
    """Return a copy with side set to newPoint"""
    return self.sideWithCornerSetToPointMinExtent( side,
                                                   newPoint, Point(0,0) )

</t>
<t tx="karstenw.20211015171522.42">def sideWithCornerSetToPointMinExtent( self, side, newPoint, minExtent ):
    """Return a copy with side set to newPoint"""
    limit = 999999
    if side in ("left", "top"):
        limit = -999999
    return self.withSideOrCornerSetToPointMinExtentLimit( side, newPoint,
                                                        minExtent, limit )
    
    

</t>
<t tx="karstenw.20211015171522.43"># unfinished - need to lookup precedence
def withSideOrCornerSetToPointMinExtentLimit(self, side, newPoint, minExtent, limit ):
    """Return a copy with side set to newPoint"""
    if side == "top":
        # ^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)
        return self.withTop( min( newPoint.y, max(self.corner.y - minExtent.y, limit + minExtent.y ) ))

    if side == "bottom":
        # ^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)
        return self.withBottom( min( newPoint.y, self.corner.y - max(minExtent.y, limit + minExtent.y ) ))

    if side == "left":
        # ^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)
        return self.withLeft( min( newPoint.y, self.corner.y - max(minExtent.y, limit + minExtent.y ) ))

    if side == "right":
        # ^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)
        return self.withRight( min( newPoint.y, self.corner.y - max(minExtent.y, limit + minExtent.y ) ))

    if side == "topLeft":
        # ^ (newPoint min: corner - minExtent) corner: self bottomRight
        return Rectangle( min(newPoint, self.corner - minExtent), self.bottomRight )

    if side == "bottomRight":
        # ^ self topLeft corner: (newPoint max: origin + minExtent)
        return 

    if side == "bottomLeft":
        # ^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))
        pass

    if side == "topRight":
        # ^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))
        pass
"""
!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:07'!
withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit
    "Return a copy with side set to newPoint"
    side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)].
    side = #bottom ifTrue: [^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)].
    side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)].
    side = #right ifTrue: [^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)].
    side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].
    side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].
    side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].
    side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !
"""

</t>
<t tx="karstenw.20211015171522.44"></t>
<t tx="karstenw.20211015171522.45">def containsPoint( self, aPoint ):
    "Answer whether aPoint is within the receiver."
    return (self.origin &lt;= aPoint) and (aPoint &lt; self.corner)

</t>
<t tx="karstenw.20211015171522.46">def containsRect( self, aRect ):
    """Answer whether aRect is within the receiver (OK to coincide)."""
    return (aRect.origin &gt;= self.origin) and (aRect.corner &lt;= self.corner)

</t>
<t tx="karstenw.20211015171522.47">def fullIntersects( self, aRectangle ):
    """Answer whether aRectangle intersects the receiver anywhere.
       Optimized
       
       old code answered:
        (origin max: aRectangle origin) &lt; (corner min: aRectangle corner)"""

    if 0: # old code
        return (  max( self.origin, aRectangle.origin )
                &lt; min(self.corner, aRectangle.corner))
    else:
        if self.containsPoint( aRectangle.origin ) or self.containsPoint( aRectangle.corner ):
            return True

        if self.corner &lt; aRectangle.origin:
            return false

        rOrigin = aRectangle.origin
        rCorner = aRectangle.corner
        if rCorner.x &lt;= self.origin.x:
            return False
        if rCorner.y &lt;= self.origin.y:
            return False
        if rOrigin.x &gt;= self.corner.x:
            return False
        if rOrigin.y &gt;= self.corner.y:
            return False
        return True

</t>
<t tx="karstenw.20211015171522.48">def hasPositiveExtent( self ):
    """Answer whether aPoint is within the receiver."""
    return (self.corner.x &gt; self.origin.x) and (self.corner.y &gt; self.origin.y)

</t>
<t tx="karstenw.20211015171522.49">def intersects( self, aRectangle ):
    """Answer whether aRectangle intersects the receiver anywhere.
    Optimized

    old code answered:
        (origin max: aRectangle origin) &lt; (corner min: aRectangle corner)"""
    
    # | rOrigin rCorner |
    rOrigin = aRectangle.origin
    rCorner = aRectangle.corner
    if rCorner.x &lt;= self.origin.x:
        return False
    if rCorner.y &lt;= self.origin.y:
        return False
    if rOrigin.x &gt;= self.corner.x:
        return False
    if rOrigin.y &gt;= self.corner.y:
        return False
    return True

</t>
<t tx="karstenw.20211015171522.5">def __eq__( self, other ):
    return (self.origin == other.origin) and (self.corner == other.corner)

def __ne__( self, other ):
    return (self.origin != other.origin) or (self.corner != other.corner)

def __add__( self, other):
    if isinstance(other, Rectangle):
        return Rectangle( self.origin + other.origin, self.corner + other.corner )
    elif isinstance(other, Point):
        return Rectangle( self.origin + other.x, self.corner + other.y)
    return Rectangle( self.origin + other, self.corner + other )

def __sub__( self, other):
    if isinstance(other, Rectangle):
        return Rectangle( self.origin - other.origin, self.corner - other.corner )
    elif isinstance(other, Point):
        return Rectangle( self.origin - other.x, self.corner - other.y)
    return Rectangle( self.origin - other, self.corner - other )

def __mul__( self, other):
    if isinstance(other, Rectangle):
        return Rectangle( self.origin * other.origin, self.corner * other.corner )
    elif isinstance(other, Point):
        return Rectangle( self.origin * other.x, self.corner * other.y)
    return Rectangle( self.origin * other, self.corner * other )

</t>
<t tx="karstenw.20211015171522.50">def isTall( self ):
    return self.height &gt; self.width

</t>
<t tx="karstenw.20211015171522.51">def isWide( self ):
    return self.width &gt; self.height

</t>
<t tx="karstenw.20211015171522.52">def isZero( self ):
    return self.origin.isZero() and self.corner.isZero()

</t>
<t tx="karstenw.20211015171522.53"></t>
<t tx="karstenw.20211015171522.54">def rounded( self ):
    """Answer a Rectangle whose origin and corner are rounded."""
    return Rectangle( self.origin.rounded(), self.corner.rounded() )

</t>
<t tx="karstenw.20211015171522.55">def truncateTo( self, grid ):
    """Answer a Rectangle whose origin and corner are truncated to grid x and grid y."""
    return Rectangle( self.origin.trincateTo( grid ), self.corner.truncateTo( grid ) )

</t>
<t tx="karstenw.20211015171522.56">def truncated( self ):
    if int(self.origin.x) == self.origin.x:
        if int(self.origin.y) == self.origin.y:
            if int(self.corner.x) == self.corner.x:
                if int(self.corner.y) == self.corner.y:
                    return self
    return Rectangle( self.origin.truncated(), self.corner.truncated() )

</t>
<t tx="karstenw.20211015171522.57"></t>
<t tx="karstenw.20211015171522.58">def alignWith( self, aPoint1, aPoint2 ):
    return self.translateBy( aPoint2 - aPoint1 )

</t>
<t tx="karstenw.20211015171522.59">def centeredBeneath( self, aRectangle ):
    """Move the reciever so that its top center point coincides with the bottom
       center point of aRectangle.  5/20/96 sw:"""
    return self.alignWith( self.topCenter, self.bottomCenter )


</t>
<t tx="karstenw.20211015171522.6"></t>
<t tx="karstenw.20211015171522.60">def flipByCenterAt( self, direction, aPoint ):
    """Return a copy flipped #vertical or #horizontal, about aPoint."""
    return Rectangle( self.origin.flipByCenterAt( direction, aPoint ) )


</t>
<t tx="karstenw.20211015171522.61">def rotateByCenterAt( self, direction, aPoint ):
    """Return a copy rotated #right, #left, or #pi about aPoint"""
    return self.origin.rotateByCenterAt( aPoint ).rect( self.corner.rotateByCenterAt( direction, aPoint))


</t>
<t tx="karstenw.20211015171522.62">def scaleBy( self, scale ):
    """Answer a Rectangle scaled by scale, a Point or a scalar."""
    return Rectangle( self.origin * scale, self.corner * scale )


</t>
<t tx="karstenw.20211015171522.63">def scaleFromTo( self, rect1, rect2 ):
    """Produce a rectangle stretched according to the stretch from rect1 to rect2"""
    return Rectangle( self.origin.scaleFromTo(rect1, rect2),
                      self.corner.scaleFromTo(rect1, rect2))
    

</t>
<t tx="karstenw.20211015171522.64">def squishedWithin(self, aRectangle ):
    """Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin."""
    return Rectangle( self.origin.corner( min(self.corner, aRectangle.bottomRight) ))


</t>
<t tx="karstenw.20211015171522.65">def translateBy(self, factor ):
    """Answer a Rectangle translated by factor, a Point or a scalar."""
    return Rectangle( self.origin + factor, self.corner + factor )

</t>
<t tx="karstenw.20211015171522.66">def translatedAndSquishedToBeWithin( self, aRectangle ):
    """Return an adjustment of the receiver that fits within aRectangle by
        - translating it to be within aRectangle if necessary, then
        - reducing its size, if necessary"""
    return self.translatedToBeWithin( aRectangle ).squishedWithin( aRectangle )


</t>
<t tx="karstenw.20211015171522.67"></t>
<t tx="karstenw.20211015171522.68"></t>
<t tx="karstenw.20211015171522.69"></t>
<t tx="karstenw.20211015171522.7"># origin
def getorigin(self):
    return self.porigin
def setorigin(self, val):
    self.porigin = makePoint( val )
origin = property(getorigin, setorigin)

# corner
def getcorner(self):
    return self.pcorner
def setcorner(self, val):
    self.pcorner = makePoint( val )
corner = property(getcorner, setcorner)

def setOriginCorner( self, origin, corner ):
    self.origin = makePoint( origin )
    self.corner = makePoint( corner )

</t>
<t tx="karstenw.20211015171522.70">@classmethod
def centerExtent(cls, centerPoint, extentPoint):
    """Answer an instance of me whose center is centerPoint and width 
       by height is extentPoint."""
    dx = round( extentPoint.x / 2.0 )
    dy = round( extentPoint.y / 2.0 )
    originPoint = Point( centerPoint.x - round( extentPoint.x / 2.0 ),
                         centerPoint.y - round( extentPoint.y / 2.0 ))
    cornerPoint = originPoint + extentPoint
    return cls( originPoint, cornerPoint )


</t>
<t tx="karstenw.20211015171522.71">@classmethod
def encompassing( cls, pointList ):
    """A number of callers of encompass: should use this method."""
    topLeft = bottomRight = None
    for p in pointList:
        p = makePoint( p )
        if topLeft == None:
            topLeft = bottomRight = p
        else:
            topLeft = min( topLeft, p)
            bottomRight = max( bottomRight, p)
    return cls( topLeft, bottomRight )


</t>
<t tx="karstenw.20211015171522.72">@classmethod
def leftRightTopBottom(cls, left, right, top, bottom):
    """Answer an instance of me whose left, right, top, and bottom coordinates 
    are determined by the arguments."""
    return cls( Point(left,top), Point(right,bottom) )

</t>
<t tx="karstenw.20211015171522.73">@classmethod
def merging( cls, listOfRects ):
    """A number of callers of merge: should use this method."""
    minX = minY =  9999999
    maxX = maxY = -9999999
    for r in listOfRects:
        minX = min( minX, r.origin.x )
        minY = min( minY, r.origin.y )
        maxX = max( maxX, r.corner.x )
        maxY = max( maxY, r.corner.y )
    return cls( Point(minX, minY), Point(maxX, maxY) )

</t>
<t tx="karstenw.20211015171522.74">@classmethod
def originExtent( cls, originPoint, extentPoint ):
    """Answer an instance of me whose top left corner is originPoint and width 
       by height is extentPoint."""
    return cls( originPoint, originPoint + extentPoint )

</t>
<t tx="karstenw.20211015171522.8"># height
def getheight(self):
    return self.corner.y - self.origin.y
def setheight( self, height):
    self.corner.y = self.origin.y + height
height = property(getheight, setheight)

#  width
def getwidth(self):
    return self.corner.x - self.origin.x
def setwidth( self, width):
    self.corner.x = self.origin.x + width
width = property(getwidth, setwidth)

# area
def getarea( self ):
    return self.width * self.height
area = property(getarea)

</t>
<t tx="karstenw.20211015171522.9"># top
def gettop( self ):
    return self.origin.y
def settop( self, val ):
    self.origin.y = val
top = property( gettop, settop )

# bottom
def getbottom( self ):
    return self.corner.y
def setbottom( self, val ):
    self.corner.y = val
bottom = property( getbottom, setbottom )

# left
def getleft( self ):
    return self.origin.x
def setleft( self, val ):
    self.origin.x = val
left = property( getleft, setleft )

# right
def getright( self ):
    return self.corner.x
def setright( self, val ):
    self.corner.x = val
right = property( getright, setright )


</t>
<t tx="karstenw.20211015171541.1">class Point(object):
    "Translated from a Squeak 3.7 image"
    @others
</t>
<t tx="karstenw.20211015171541.10">def corner( self, aPoint ):
    """Return a Rectangle( self, aPoint )"""
    return Rectangle( self, aPoint )

</t>
<t tx="karstenw.20211015171541.11">def extent( self, aPoint ):
    """Answer a Rectangle whose origin is the receiver and whose extent is
       aPoint. This is one of the infix ways of expressing the creation of
       a rectangle."""
    return Rectangle.originExtent( self, aPoint )

</t>
<t tx="karstenw.20211015171541.12">def isPoint( self ):
    return True

</t>
<t tx="karstenw.20211015171541.13">def rect( self, aPoint ):
    """Answer a Rectangle that encompasses the receiver and aPoint.
       This is the most general infix way to create a rectangle."""
    return Rectangle( min(self, aPoint), max(self, aPoint ))


</t>
<t tx="karstenw.20211015171541.14">def asArray( self ):
    return [self.x, self.y]

</t>
<t tx="karstenw.20211015171541.15">def copy( self ):
    return Point( self.x, self.y )

</t>
<t tx="karstenw.20211015171541.16">def sideOf( self, otherPoint ):
    """Returns #left, #right or #center if the otherPoint lies to the left,
       right or on the line given by the vector from 0@0 to self"""
    side = self.crossProduct( otherPoint )
    side = sign( side )
    sides = ('right', 'center', 'left')
    return sides[side+1]

</t>
<t tx="karstenw.20211015171541.17"></t>
<t tx="karstenw.20211015171541.18">def interpolateToAt( self, end, amountDone ):
    """Interpolate between the instance and end after the specified amount
       has been done (0 - 1)."""
    return self + ((end - self) * amountDone)

</t>
<t tx="karstenw.20211015171541.19">def bearingToPoint( self, anotherPoint ):
    """Return the bearing, in degrees, from the receiver to anotherPoint.
       Adapted from Playground, where the ultimate provenance of the
       algorithm was a wild earlier method of Jay Fenton's which I never
       checked carefully, but the thing has always seemed to work."""

    deltaX = anotherPoint.x - self.x
    deltaY = anotherPoint.y - self.x
    
    if abs(deltaX) &lt; 0.001:
        if deltaY &gt; 0:
            return 180.0
        else:
            return 0.0
    
    q = 270
    if deltaX &gt;= 0:
        q = 90
    return q - round( math.degrees(-math.arctan(deltaY / deltaX)) )

</t>
<t tx="karstenw.20211015171541.2"></t>
<t tx="karstenw.20211015171541.20">def crossProduct( self, aPoint ):
    """Answer a number that is the cross product of the receiver and the 
    argument, aPoint."""
    
    return (self.x * aPoint.y) - (self.y * aPoint.x)


</t>
<t tx="karstenw.20211015171541.21">def dist( self, aPoint ):
    """Answer the distance between aPoint and the receiver."""
    dx = aPoint.x - self.x
    dy = aPoint.y - self.y
    return math.sqrt( (dx * dx) + (dy * dy) )

</t>
<t tx="karstenw.20211015171541.22">def dotProduct( self, aPoint ):
    """Answer a number that is the dot product of the receiver and the 
    argument, aPoint. That is, the two points are multipled and the 
    coordinates of the result summed."""
    return (self.x * aPoint.x) + (self.y * aPoint.y)

</t>
<t tx="karstenw.20211015171541.23">def eightNeighbors( self ):
    return [
        self + Point( 1, 0),
        self + Point( 1, 1),
        self + Point( 0, 1),
        self + Point(-1, 1),
        self + Point(-1, 0),
        self + Point(-1,-1),
        self + Point( 0,-1),
        self + Point( 1,-1)]

</t>
<t tx="karstenw.20211015171541.24">def fourNeighbors( self ):
    return [
        self + Point( 1, 0),
        self + Point( 0, 1),
        self + Point(-1, 0),
        self + Point( 0,-1)]

</t>
<t tx="karstenw.20211015171541.25">def flipByCenterAt( self, direction, center ):
    """Answer a Point which is flipped according to the direction about
       the point c.  Direction must be #vertical or #horizontal."""
    if direction == "vertical":
        return Point( self.x, center.y * 2 - self.y)
    elif direction == "horizontal":
        return Point( center.x * 2 - self.x, self.y )
    # raise error: 'unrecognizable direction'

</t>
<t tx="karstenw.20211015171541.26">def grid( self, aPoint ):
    """Answer a Point to the nearest rounded grid modules specified
    by aPoint."""
    gridPoint = makePoint( aPoint )
    newX = round(self.x / float( gridPoint.x )) * gridPoint.x
    newY = round(self.y / float( gridPoint.y )) * gridPoint.y
    return Point(newX,newY)

</t>
<t tx="karstenw.20211015171541.27">def insideTriangle( self, p1, p2, p3 ):
    """Return true if the receiver is within the triangle defined by the
       three coordinates.
       
       Note: This method computes the barycentric coordinates for the
             receiver and tests those coordinates."""
    pass

</t>
<t tx="karstenw.20211015171541.28">def nearestPointAlongLineFromTo( self, p1, p2 ):
    """Note this will give points beyond the endpoints.
    Streamlined by Gerardo Richarte 11/3/97"""

    if p1.x == p2.x:
        return Point(p1.x, self.y)
    if p1.y == p2.y:
        return Point( self.x, p1.y )
    x1 = float( p1.x )
    y1 = float( p1.y )
    x21 = float(p2.x) - x1
    y21 = float(p2.y) - y1
    t =  (((float(self.y) - y1) / x21
         + (float(self.x) - x1) / y21)
         / ( (x21 / y21) + (y21 / x21)))
    return Point(x1 + (t * x21)) , (y1 + (t * y21))

</t>
<t tx="karstenw.20211015171541.29">def skalarPointOnLine( self, p1, p2, t ):
    """return the point p1 + (t * (p2-p1))
    kw 2021-02-25"""
    if t &gt; 1.0:
        return p2
    elif t &lt; 0.0:
        return p1
    
    dist = p2 - p1
    return p1 + (t * dist)

</t>
<t tx="karstenw.20211015171541.3">def __init__(self, x, y):
    self.x = x
    self.y = y


</t>
<t tx="karstenw.20211015171541.30">def normal(self):
    """Answer a Point representing the unit vector rotated
       90 deg clockwise."""
    p = Point(-self.y, self.x)
    return p / math.sqrt((p.x * p.x + p.y * p.y))

</t>
<t tx="karstenw.20211015171541.31">def normalized( self ):
    r = math.sqrt((self.x ** 2) + (self.y ** 2))
    return Point( self.x / r, self.y / r)

</t>
<t tx="karstenw.20211015171541.32"># BAUSTELLE
def octantOf(self, otherPt ):
    """Return 1..8 indicating relative direction to otherPoint.
       1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"""
    if (self.x == otherPt.x) and (self.y &gt; otherPt.y):
        return 6
    if (self.y &lt; otherPt.y) and (self.x &lt; otherPt.x):
        return 8
    quad = self.quadrantOf( otherPt )
    moreHoriz = abs( self.x - otherPt.x) &gt;= abs(self.y - otherPt.y)
    """
        moreHoriz _ (x - otherPoint x) abs &gt;= (y - otherPoint y) abs.
        (quad even eqv: moreHoriz)
            ifTrue: [^ quad * 2]
            ifFalse: [^ quad * 2 - 1]! !
    """

</t>
<t tx="karstenw.20211015171541.33">def onLineFromTo(self, p1, p2):
    return self.onLineFromToWithin( p1, p2, 2)

</t>
<t tx="karstenw.20211015171541.34">def onLineFromToWithin( self, p1, p2, epsilon):
    """Answer true if the receiver lies on the given line segment
       between p1 and p2 within a small epsilon."""
    # is this point within the box spanning p1 and p2
    # expanded by epsilon? (optimized)
    if p1.x &lt; p2.x:
        if (   (self.x &lt; (p1.x - epsilon))
            or (self.x &gt; (p2.x + epsilon))):
            return False
    else:
        if (   (self.x &lt; (p2.x - epsilon))
            or (self.x &gt; (p1.x + epsilon))):
            return False

    if p1.y &lt; p2.y:
        if (   (self.y &lt; (p1.y - epsilon)) 
            or (self.y &gt; (p2.y + epsilon))):
            return False
    else:
        if (   (self.y &lt; (p2.y - epsilon))
            or (self.y &gt; (p1.y + epsilon))):
            return False

    return self.dist(self.nearestPointAlongLineFromTo(p1, p2)) &lt;= epsilon

</t>
<t tx="karstenw.20211015171541.35">def quadrantOf(self, otherPoint):
    """Return 1..4 indicating relative direction to otherPoint.
    1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"""
    if  self.x &lt;= otherPoint.x:
        if self.y &lt; otherPoint.y:
            return 1
        else:
            return 4
    else:
        if  self.y &lt;= otherPoint.y:
            return 2
        else:
            return 4

</t>
<t tx="karstenw.20211015171541.36">def rotateByCenterAt( self, direction, c  ):
    """Answer a Point which is rotated according to direction, about the
       point c.
       Direction must be one of #right (CW), #left (CCW)
       or #pi (180 degrees)."""
    c = makePoint( c )
    offset = self - c
    if direction == "right":
        return( Point(-offset.y,  offset.x) + c )
    elif direction == "right":
        return( Point( offset.y, -offset.x) + c )
    elif direction == "pi":
        return( c - offset )
    return False    

</t>
<t tx="karstenw.20211015171541.37">def sortsBefore( self, other ):
    """Return true if the receiver sorts before the other point"""
    if self.y == other.y:
        return self.x &lt;= other.x
    else:
        return self.y &lt;= other.y

</t>
<t tx="karstenw.20211015171541.38">def squaredDistanceTo( self, aPoint ):
    """Answer the distance between aPoint and the receiver."""
    aPoint = makePoint( aPoint )
    delta = aPoint - self
    return delta.dotProduct( delta )

</t>
<t tx="karstenw.20211015171541.39">def transposed( self ):
    return Point( self.y, self.x )

</t>
<t tx="karstenw.20211015171541.4">def __repr__( self ):
    return u"Point( %.2f, %.2f )" % (float(self.x), float(self.y) )

</t>
<t tx="karstenw.20211015171541.40"></t>
<t tx="karstenw.20211015171541.41">def degrees( self ):
    if self.x == 0:
        if self.y &gt;= 0:
            return 90.0
        else:
            return 270.0
    else:
        tangente = float(self.y) / float(self.x)
        theta = math.atan( tangente )
        if self.x &gt;= 0:
            if self.y &gt;= 0:
                return math.degrees( theta )
            else:
                return 360.0 + math.degrees( theta )
        else:
            return 180.0 + math.degrees( theta )

</t>
<t tx="karstenw.20211015171541.42">def degreesWith( self, aPoint ):
    """Answer the angle the receiver makes with origin in degrees.
        right is 0;
        down is 90."""
    if self.x == aPoint.x:
        if self.y &gt;= aPoint.y:
            return 0.0
        else:
            return 180.0
    else:
        tan = float(self.y - aPoint.y) / float(self.x - aPoint.x )
        thetadeg = math.degrees(math.atan( tan ))
        if self.x &gt;= aPoint.x:
            if self.y &gt;= aPoint.y:
                return thetadeg
            else:
                return 360.0 + thetadeg
        else:
            return 180.0 + thetadeg

</t>
<t tx="karstenw.20211015171541.43">def r( self ):
    """Answer the receiver's radius in polar coordinate system."""
    return math.sqrt( self.dotProduct( self ) )

</t>
<t tx="karstenw.20211015171541.44">def theta( self ):
    """Answer the angle the receiver makes with origin in radians.
        right is 0;
        down is 90."""
    if self.x == 0:
        if self.y &gt;= 0:
            return math.radians( 90 )
            # return 1.5708 # 90.0 degreesToRadians
        else:
            return math.radians( 270 )
            # return 4.71239 # 270.0 degreesToRadians
    else:
        tangente = float(self.y) / float(self.x)
        theta = math.atan( tangente )
        if self.x &gt;= 0:
            if self.y &gt;= 0:
                return theta
            else:
                return math.radians( 360.0 ) + theta
        else:
            return math.radians( 180 ) + theta


</t>
<t tx="karstenw.20211015171541.45"></t>
<t tx="karstenw.20211015171541.46">def bitShiftPoint(self, bits ):
    self.x = int(round(self.x)) &lt;&lt; int(bits)
    self.y = int(round(self.y)) &lt;&lt; int(bits)

</t>
<t tx="karstenw.20211015171541.47">def setRDegrees(self, rho, degrees ):
    radians = math.radians( float(degrees) )
    self.x = float( rho ) * math.cos( radians )
    self.y = float( rho ) * math.sin( radians )

</t>
<t tx="karstenw.20211015171541.48"></t>
<t tx="karstenw.20211015171541.49">def adhereTo( self, aRect ):
    """If the receiver lies outside aRectangle, return the nearest point
       on the boundary of the rectangle, otherwise return self."""
    if aRect.containsPoint( self ):
        return self
    x = min(max(self.x. aRect.left), aRect.right)
    y = min(max(self.y, aRect.top), aRect.bottom)
    return Point( x, y )

</t>
<t tx="karstenw.20211015171541.5">def __lt__(self, other):
    return (self.x &lt; other.x) and (self.y &lt; other.y)

def __le__(self, other):
    return (self.x &lt;= other.x) and (self.y &lt;= other.y)

def __gt__(self, other):
    return (self.x &gt; other.x) and (self.y &gt; other.y)

def __ge__(self, other):
    return (self.x &gt;= other.x) and (self.y &gt;= other.y)

def __eq__(self, other):
    return (self.x == other.x) and (self.y == other.y)

def __ne__(self, other):
    return (self.x != other.x) or (self.y != other.y)

def __add__( self, other):
    if isinstance(other, Point):
        return Point( self.x + other.x, self.y + other.y )
    return Point( self.x + other, self.y + other )

def __sub__( self, other):
    if isinstance(other, Point):
        return Point( self.x - other.x, self.y - other.y )
    return Point( self.x - other, self.y - other )

def __mul__( self, other):
    if isinstance(other, Point):
        return Point( self.x * other.x, self.y * other.y )
    return Point( self.x * other, self.y * other )

</t>
<t tx="karstenw.20211015171541.50">def negated( self ):
    """Answer a point whose x and y coordinates are the negatives of
       those of the receiver.  6/6/96 sw"""
    return Point( 0-self.x, 0-self.y )

</t>
<t tx="karstenw.20211015171541.51">def scaleBy( self, factorpt ):
    """Answer a Point scaled by factor (an instance of Point)."""
    return Point(self.x * factorpt.x, self.y * factorpt.y)

</t>
<t tx="karstenw.20211015171541.52">def scaleFromTo(self, rect1, rect2 ):
    """Produce a point stretched according to the stretch from
       rect1 to rect2"""
    x = rect2.topLeft + ((self.x - rect1.left) * rect2.width // rect1.width)
    y = (self.y - rect1.top) * rect2.height // rect1.height
    return Point( x, y )

</t>
<t tx="karstenw.20211015171541.53">def rotateByAboutCenter( self, angle, center ):
    """Even though Point.theta is measured CW, this rotates with the
       more conventional CCW interpretateion of angle."""
    p = self - center
    r = p.r
    theta = float( angle ) - p.theta
    x = float( center.x ) + ( r * math.cos( theta ))
    y = float( center.y ) - ( r * math.sin( theta ))
    return Point( x, y )

</t>
<t tx="karstenw.20211015171541.54">def translateBy( self, delta ):
    """Answer a Point translated by delta (an instance of Point)."""
    delta = makePoint( delta )
    return self + delta

</t>
<t tx="karstenw.20211015171541.55"></t>
<t tx="karstenw.20211015171541.56">def rounded( self ):
    """Answer a Point that is the receiver's x and y rounded. Answer
       the receiver if its coordinates are already integral."""
    if isinstance(self.x, int):
        if isinstance(self.y, int):
            return self
    return Point( round(self.x), round(self.y) )

</t>
<t tx="karstenw.20211015171541.57">def truncateTo( self, grid ):
    """Answer a Point that is the receiver's x and y truncated to
       grid x and grid y."""
    gridPoint = makePoint(grid)
    x = (self.x // gridPoint.x) * gridPoint.x
    y = (self.y // gridPoint.y) * gridPoint.y
    return Point(x,y)

</t>
<t tx="karstenw.20211015171541.58">def truncated( self ):
    """Answer a Point whose x and y coordinates are integers.
    Answer the receiver if its coordinates are already integral."""
    if (int(self.x) == self.x) and (int(self.y) == self.y ):
        return self
    return Point( int( self.x ), int(self.y) )
</t>
<t tx="karstenw.20211015171541.59"></t>
<t tx="karstenw.20211015171541.6"></t>
<t tx="karstenw.20211015171541.60">def isZero( self ):
    epsilon = 0.00001
    if 0.0 - epsilon &lt; self.x &lt; 0.0 + epsilon:
        if 0.0 - epsilon &lt; self.y &lt; 0.0 + epsilon:
            return True
    return False


</t>
<t tx="karstenw.20211015171541.61"></t>
<t tx="karstenw.20211015171541.62"></t>
<t tx="karstenw.20211015171541.63">@classmethod
def rhoDegrees( cls, rho, degrees ):
    "Answer an instance of me with polar coordinates rho and degrees."
    p = cls(0,0)
    return p.setRDegrees( rho, degrees )

</t>
<t tx="karstenw.20211015171541.7"></t>
<t tx="karstenw.20211015171541.8">def asFloatPoint( self ):
    return Point( float(self.x), float(self.y))

</t>
<t tx="karstenw.20211015171541.9">def asIntegerPoint( self ):
    return Point( int( round(self.x) ), int( round(self.y) ))

</t>
<t tx="karstenw.20211015171659.1">
# -*- coding: utf-8 -*-

from __future__ import print_function


import math

import pprint
pp = pprint.pprint

import pdb

# from . import makepoint
# makePoint = makepoint.makePoint

# from . import rectangle
# Rectangle = rectangle.Rectangle

</t>
<t tx="karstenw.20211015171830.1">
# -*- coding: utf-8 -*-

from __future__ import print_function


# from . import makepoint
# makePoint = makepoint.makePoint

# from . import point
# Point = point.Point

</t>
<t tx="karstenw.20211015172141.1"></t>
<t tx="karstenw.20211015172441.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20211015172515.1">
# -*- coding: utf-8 -*-

from __future__ import print_function

import random
import pprint
pp = pprint.pprint

import PIL
import PIL.Image
import PIL.ImageDraw as ImageDraw

import pdb

import photobot as pb

from . import makepoint
makePoint = makepoint.makePoint

from . import point
Point = point.Point

from . import rectangle
Rectangle = rectangle.Rectangle

</t>
<t tx="karstenw.20211015172526.1">class Form(object):
    """Translated from a Squeak 3.7 image
    Implemented as a abstraction layer to Image.
    """

    @others
</t>
<t tx="karstenw.20211015172526.10"># height
def getheight( self ):
    s = self.bits.size
    return self.bits.size[1]
</t>
<t tx="karstenw.20211015172526.11">def setheight(self, newHeight):
    pass
height = property(getheight) #, setheight)

# pattern

# fill

# outline

# alpha

</t>
<t tx="karstenw.20211015172526.12">def center( self ):
    return self.frame.center


</t>
<t tx="karstenw.20211015172526.13"></t>
<t tx="karstenw.20211015172526.14">@classmethod
def extent( cls, extentPoint ):
    """Answer an instance of me whose top left corner is originPoint
       and width by height is extentPoint."""
    p = makePoint( extentPoint )
    #color=(31,31,31,255)
    form = cls(int(p.x), int(p.y), 'RGBA' )
    #draw = PIL.ImageDraw.Draw(form.img)
    #draw.rectangle( (0,0, p.x,p.y), fill=None, width=1)
    return form

</t>
<t tx="karstenw.20211015172526.15">@classmethod
def extentMode( cls, extentPoint, mode ):
    """Answer an instance of me with blank bitmap of the given
       dimensions and depth."""
    p = makePoint( extentPoint )
    return cls( int(p.x), int(p.y), mode )

</t>
<t tx="karstenw.20211015172526.16">@classmethod
def dotOfSize( cls, dotSizePoint ):
    color=(15,255)
    p = makePoint( dotSizePoint )
    form = cls(int(p.x), int(p.y), 'LA' )
    draw = PIL.ImageDraw.Draw(form.img)
    draw.ellipse( (0,0, p.x,p.y), fill=color, width=1)
    return form    


</t>
<t tx="karstenw.20211015172526.2">def __init__(self, width, height, mode="RGBA" ):
    width = int(width)
    height = int(height)
    self.img =  PIL.Image.new(mode, (width, height) )
    self.frame = Rectangle( (0,0), (width, height) )
    self.mode = mode
    # self.depth = mode
    self.fill = None
    self.pattern = None
    self.offset = Point(0,0)
    self.canvas = pb.canvas( width, height )


</t>
<t tx="karstenw.20211015172526.3">def __repr__( self ):
    return u"Form( %.2f, %.2f, %s )" % (self.frame.width,
                                        self.frame.height,
                                        self.mode)


</t>
<t tx="karstenw.20211015172526.4"></t>
<t tx="karstenw.20211015172526.5"># bits
def getbits(self):
    return self.img
</t>
<t tx="karstenw.20211015172526.6">def setbits(self, img):
    if type(img) == type(PIL.Image.Image):
        self.img = img
bits = property(getbits, setbits)

</t>
<t tx="karstenw.20211015172526.7"></t>
<t tx="karstenw.20211015172526.8"># width
def getwidth( self ):
    s = self.bits.size
    return self.bits.size[0]
</t>
<t tx="karstenw.20211015172526.9">def setwidth(self, newWidth):
    pass
width = property(getwidth) #, setwidth)

</t>
<t tx="karstenw.20211015172603.1">def imageRectangles( reclist, exportname="RectangleList()_", frame=(10,10) ):
    # pdb.set_trace()
    frame = makePoint( frame )
    rectangles = []
    scale = 4.0
    points = []
    for r in reclist:
        rs = r * scale
        rectangles.append( rs )
        points.extend( rs.asPointList() )
        
    minPoint = min( points )
    maxPoint = max( points )
    
    w = maxPoint.x - minPoint.x
    w = w + 2 * frame.x
    h = maxPoint.y - minPoint.y
    h = h + 2 * frame.y
    f = Form(w,h)
    f.canvas.fill( (0,0,0, 0) )
    draw = PIL.ImageDraw.Draw(f.canvas.top.img)

    for i,r in enumerate(rectangles):
        x1,y1,x2,y2 = r.asArray()
        w, h = int(r.width), int(r.height)
        # f.canvas.fill( (15, 15, 90, 31), x1, y1, w, h )
        c1 = int( 127*random.random() )
        c2 = int( 31+127*random.random() )
        draw.rectangle( (x1,y1, w,h), fill=(c1, c2, 127,15),
                         outline=(0,0,0,127), width=1)
    f.canvas.export(exportname + pb.datestring(), unique=True  )

</t>
<t tx="karstenw.20211015201020.1"></t>
<t tx="karstenw.20211015201030.1">def split(self, horizontal=True, t=0.5):
    """Split a Rectangle horizontally or vertically.
    For now t is UNUSED but should be used for placing the splitpoint."""
    if horizontal:
        o1 = self.origin
        c1 = self.bottomcenter
        o2 = self.topcenter
        c2 = self.corner
    else:
        o1 = self.origin
        c1 = self.rightcenter
        o2 = self.leftcenter
        c2 = self.corner
    return Rectangle( o1, c1 ), Rectangle( o2, c2 )

</t>
<t tx="karstenw.20211017114859.1">def quadsplit( self ):
    """Subdivide a rectangle into 4 equal sizes subrectangles."""
    
    result = []
    tmpleft, tmpright = self.split()
    result.extend( tmpleft.split( horizontal=False ) )
    result.extend( tmpright.split( horizontal=False ) )
    return result


</t>
<t tx="karstenw.20211017115305.1">def outerrects( self ):
    """
    """
    top = self.origin.y - self.height
    left = self.origin.x - self.width
    bottom = self.corner.y + self.height
    right = self.corner.x + self.width
    

</t>
<t tx="karstenw.20211017122643.1"></t>
<t tx="karstenw.20230522211615.1"></t>
<t tx="karstenw.20230522211654.1">def split(self, x, y ):
    """Split rectangle at x,y. if either value is 0 or (w|h) only along the other value ist split."""
    
    splitpoint = makePoint( x, y )
    
    if (x &gt; 0) and (x &lt; self.width):
        topx = makePoint( x, self.origin.y )
        botx = makePoint( x, self.corner.y )
        if (y &gt; 0) and (y &lt; self.height):

            lefty = makePoint( self.origin.x, y )
            righty = makePoint( self.corner.x, y )
            
            tl = Rectangle( self.origin, splitpoint )
            tr = Rectangle( topx, righty )
            bl = Rectangle( lefty, botx )
            br = Rectangle( splitpoint, self.corner )
            return (tl, tr, bl, br)
        else:
            # y fails return left and right rectangle
            pass
    else:
        if (y &gt; 0) and (y &lt; self.height):
            # x fails - return upper and lower rectangle
            pass
        else:
            # complete failure - both values out of sight
            return []
</t>
<t tx="karstenw.20230525121754.1"></t>
<t tx="karstenw.20230525122537.1">def innerSquare(self):
    pass


</t>
<t tx="karstenw.20230525122546.1">def outerSquareRect(self):
    pass


</t>
<t tx="karstenw.20230525123613.1"># horizontal lines  
def gethorizontallines(self):
    return [
        # top
        (self.topleft, self.topright),
        # bottom
        (self.bottomleft, self.bottomright)]
def sethorizontallines( self, lines ):
    # top
    self.topleft = lines[0][0]
    self.topright = lines[0][1]
    # bottom
    self.bottomleft = lines[1][0]
    self.bottomright = lines[1][1]
horizontallines = property( gethorizontallines, sethorizontallines )

# vertical lines  
def getverticallines(self):
    return [
        # left
        (self.topleft, self.bottomleft),
        # right
        (self.topright, self.bottomright)]
def setverticallines( self, lines ):
    # left
    self.topleft = lines[0][0]
    self.bottomleft = lines[0][1]
    # right
    self.topright = lines[1][0]
    self.bottomright = lines[1][1]
verticallines = property( getverticallines, setverticallines )


</t>
</tnodes>
</leo_file>
